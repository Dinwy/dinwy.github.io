<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithms on Dinwy&#39;s blog</title>
    <link>https://dinwy.github.io/algorithm/</link>
    <description>Recent content in Algorithms on Dinwy&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 27 Mar 2020 00:11:58 +0900</lastBuildDate>
    
	<atom:link href="https://dinwy.github.io/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LeetCode/110. BalancedBinaryTree</title>
      <link>https://dinwy.github.io/algorithm/2020/BalancedBinaryTree/</link>
      <pubDate>Fri, 27 Mar 2020 00:11:58 +0900</pubDate>
      
      <guid>https://dinwy.github.io/algorithm/2020/BalancedBinaryTree/</guid>
      <description>Link  https://leetcode.com/problems/balanced-binary-tree/  Summary I was super confused about this problem and took a day to solve it.  Really need to think about how to go to all nodes with DFS.
Solutions My Solution I finally reached the solution with DFS. However I used try catch witch doesn&amp;rsquo;t really needed.
public bool IsBalanced(TreeNode root) { try { Height(root); return true; } catch { return false; } } public int Height(TreeNode node) { if (node == null) { return 0; } else { var left = Height(node.</description>
    </item>
    
    <item>
      <title>LeetCode/108. ConvertSortedArrayToBST</title>
      <link>https://dinwy.github.io/algorithm/2020/ConvertSortedArrayToBST/</link>
      <pubDate>Sun, 22 Mar 2020 19:50:49 +0900</pubDate>
      
      <guid>https://dinwy.github.io/algorithm/2020/ConvertSortedArrayToBST/</guid>
      <description>Link  https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/  Summary I was taking break way more than it should be. Also I totally misunderstood this problem.  I really should read document carefully.
Solutions My Solution The below is my first solution without caring many things.
public class ConvertSortedArrayToBST { public TreeNode SortedArrayToBST(int[] nums) { if (nums.Length == 0) return null; var output = new TreeNode(0); Recursion(ref output.left, nums); return output.left; } private void Recursion(ref TreeNode output, int[] nums) { if (nums.</description>
    </item>
    
    <item>
      <title>LeetCode/104. MaximumDepthOfBinaryTree</title>
      <link>https://dinwy.github.io/algorithm/2020/MaximumDepthOfBinary/</link>
      <pubDate>Tue, 17 Mar 2020 21:24:12 +0900</pubDate>
      
      <guid>https://dinwy.github.io/algorithm/2020/MaximumDepthOfBinary/</guid>
      <description>Link  https://leetcode.com/problems/maximum-depth-of-binary-tree  Summary Find a maximum depth of Binary Tree.
Solutions My Solution I was thinking about solving this problem with BFS but realized DFS is much easy to solve this problem after making some mistakes.
public class MaximumDepthOfBinaryTree { public int MaxDepth(TreeNode root) { var sum = 0; return Recursion(root, sum); } public int Recursion(TreeNode root, int sum) { if (root == null) return sum; sum++; return Math.</description>
    </item>
    
    <item>
      <title>LeetCode/101. SymmetricTree</title>
      <link>https://dinwy.github.io/algorithm/2020/SymmetricTree/</link>
      <pubDate>Tue, 17 Mar 2020 20:31:19 +0900</pubDate>
      
      <guid>https://dinwy.github.io/algorithm/2020/SymmetricTree/</guid>
      <description>Link  https://leetcode.com/problems/symmetric-tree  Summary Figure out given TreeNode is symmetric or not. I was thinking for a while and able to get an answer.
Solutions My Solution I feel like now I have some mindset that I can solve programming problem with using my brain. Using BFS to find an answer.
public class SymmetricTree { public bool IsSymmetric(TreeNode root) { if (root == null) return true; var result = true; var queue = new Queue&amp;lt;TreeNode&amp;gt;(); queue.</description>
    </item>
    
    <item>
      <title>LeetCode/100. SameTree</title>
      <link>https://dinwy.github.io/algorithm/2020/SameTree/</link>
      <pubDate>Tue, 17 Mar 2020 18:52:36 +0900</pubDate>
      
      <guid>https://dinwy.github.io/algorithm/2020/SameTree/</guid>
      <description>Link  https://leetcode.com/problems/same-tree  Summary Find the tree is the same.
Solutions My Solution Solved directly when I saw this problem. Also my solution is one of the best answers. This question not asking about optimization.  Basically this is the same question as 70.ClimbingStairs.
public bool IsSameTree(TreeNode p, TreeNode q) { if (p == null &amp;amp;&amp;amp; q != null) return false; if (p != null &amp;amp;&amp;amp; q == null) return false; if (p == null &amp;amp;&amp;amp; q == null) return true; if (p.</description>
    </item>
    
    <item>
      <title>LeetCode/83. RemoveDuplicatesFromSortedList</title>
      <link>https://dinwy.github.io/algorithm/2020/RemoveDuplicatesFromSortedList/</link>
      <pubDate>Mon, 16 Mar 2020 23:29:15 +0900</pubDate>
      
      <guid>https://dinwy.github.io/algorithm/2020/RemoveDuplicatesFromSortedList/</guid>
      <description>Link  https://leetcode.com/problems/remove-duplicates-from-sorted-list  Summary Solutions My Solution When I was solving this problem I made mistakes at start.
 I didn&amp;rsquo;t think about it is SortedLists. Which make me use HashSet.  Also I was confused using pointer properly. Was thinking too much ended up using 3 pointers.
public ListNode Solution(ListNode head) { var output = new ListNode(0); var resultNode = output; var outputTail = head; var dict = new HashSet&amp;lt;int&amp;gt;(); while (outputTail !</description>
    </item>
    
    <item>
      <title>LeetCode/70. ClimbingStairs</title>
      <link>https://dinwy.github.io/algorithm/2020/ClimbingStairs/</link>
      <pubDate>Mon, 16 Mar 2020 20:19:55 +0900</pubDate>
      
      <guid>https://dinwy.github.io/algorithm/2020/ClimbingStairs/</guid>
      <description>Link  https://leetcode.com/problems/climbing-stairs/  Solutions My Solution I used Dynamic Programming to solve this problem. Quite easy to solve to me.
public int Solution(int n) { var arr = new int[n + 1]; return Recursion(n, arr); } private int Recursion(int n, int[] arr) { if (n &amp;lt; 0) return 0; if (n == 0) return 1; if (arr[n] != 0) return arr[n]; arr[n] = Recursion(n - 1, arr) + Recursion(n - 2, arr); return arr[n]; }  Best Solution However the best answer says that this is a Fibonacci problem.</description>
    </item>
    
    <item>
      <title>LeetCode/67. AddBinary</title>
      <link>https://dinwy.github.io/algorithm/2020/AddBinary/</link>
      <pubDate>Mon, 16 Mar 2020 19:12:48 +0900</pubDate>
      
      <guid>https://dinwy.github.io/algorithm/2020/AddBinary/</guid>
      <description>Link https://leetcode.com/problems/add-binary/
Summary Given two binary strings and return their sum. 
Solutions My Solution In my solution, the idea using two pointer was correct. However checking for the short and long string was a bit too much.
public string Solution(string a, string b) { var shorterString = &amp;quot;&amp;quot;; var longerString = &amp;quot;&amp;quot;; int pointerS, pointerL = 0; var output = &amp;quot;&amp;quot;; if (a.Length &amp;gt; b.Length) { shorterString = b; pointerS = b.</description>
    </item>
    
    <item>
      <title>LeetCode/58. LengthOfLastWord &amp; LeetCode/66. PlusOne</title>
      <link>https://dinwy.github.io/algorithm/2020/LengthOfLastWordAndPlusOne/</link>
      <pubDate>Fri, 13 Mar 2020 20:16:45 +0900</pubDate>
      
      <guid>https://dinwy.github.io/algorithm/2020/LengthOfLastWordAndPlusOne/</guid>
      <description>Link  https://leetcode.com/problems/length-of-last-word https://leetcode.com/problems/plus-one  Summary  Length Of Last Word is not even a algorithm question.  PlusOne was really easy but I was making a simple mistake which should be handled.   Solutions My Solution I&amp;rsquo;ll skip explaining #58.
public int Solution(string s) { var res = 0; for (int i = s.Length - 1; i &amp;gt;= 0; i--) { if (Char.IsWhiteSpace(s[i])) { if (res != 0) return res; res = 0; continue; } res++; } return res; }   PlusOne was interesting because I was missing two thing.</description>
    </item>
    
    <item>
      <title>LeetCode/53. MaximumSubarray</title>
      <link>https://dinwy.github.io/algorithm/2020/MaximumSubarray/</link>
      <pubDate>Thu, 12 Mar 2020 22:07:35 +0900</pubDate>
      
      <guid>https://dinwy.github.io/algorithm/2020/MaximumSubarray/</guid>
      <description>Link  https://leetcode.com/problems/maximum-subarray  Summary Getting maximum sub array. Writing in hand make this much easier to solve. took 13 mins to solve with O(n) complexity. However the problem asked me solve this in a better time complexity.
Solutions My Solution After checking the solution, my solution was actual very close to the best solution. I could think about DP solution by using previous values.
public int SolutionOn(int[] nums) { var subsetSum = 0; var max = nums[0]; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>LeetCode/35. SearchInsertPosition</title>
      <link>https://dinwy.github.io/algorithm/2020/SearchInsertPosition/</link>
      <pubDate>Thu, 12 Mar 2020 20:58:48 +0900</pubDate>
      
      <guid>https://dinwy.github.io/algorithm/2020/SearchInsertPosition/</guid>
      <description>Link https://leetcode.com/problems/search-insert-position/
Summary The problem was easy. However it was asking how to solve the problem with O(logn) complexity rather than O(n)
Solutions My Solution I&amp;rsquo;ve solved the problem when I saw the problem however not thinking about the O(logn) solution.
public int SearchInsertOn(int[] nums, int target) { int idx = 0; for (int i = 0; i &amp;lt; nums.Length; i++) { if (nums[i] &amp;lt; target) { idx++; continue; } else { break; } } return idx; }  Best Solution The best solution is using binary search method Keep checking low and high and split into 2 section.</description>
    </item>
    
    <item>
      <title>LeetCode/21. MergeTwoSortedLists</title>
      <link>https://dinwy.github.io/algorithm/2020/MergeTwoSortedLists/</link>
      <pubDate>Thu, 12 Mar 2020 20:03:48 +0900</pubDate>
      
      <guid>https://dinwy.github.io/algorithm/2020/MergeTwoSortedLists/</guid>
      <description>Link https://leetcode.com/problems/merge-two-sorted-lists/
Summary This was asking same question as AddTwoNumbers. Can properly reference next in LinkedArray.  Still quite slow, but solving much faster than before.
Solutions My Solution I was a bit confused which order comes first outputTail.next or outputTail. But it is obvious. The proper steps will be,
 Assign a new value to the outputTail.next via new ListNode(x). Change the pointer(ref) of outputTail to outputTail.next which is a new value has been assigned.</description>
    </item>
    
    <item>
      <title>LeetCode/20. Valid Parentheses</title>
      <link>https://dinwy.github.io/algorithm/2020/ValidParentheses/</link>
      <pubDate>Thu, 12 Mar 2020 00:15:11 +0900</pubDate>
      
      <guid>https://dinwy.github.io/algorithm/2020/ValidParentheses/</guid>
      <description>Preface I think I&amp;rsquo;ve already solved this problem on CodeWars. But it is a good exercise solve this problem again.
Link https://leetcode.com/problems/valid-parentheses
Summary This is asking two things, can you use Stack and Dictionary. When I was solving this first time, I was more thinking about using three HashSet. However after thinking and checking the best solution, I only need a single Dictionary &amp;amp; temporary Stack to validate.
Solution My First Solution public bool IsValidFirstSolution(string s) { var stack = new Stack&amp;lt;string&amp;gt;(s.</description>
    </item>
    
    <item>
      <title>LeetCode/7. ReverseInteger &amp; LeetCode/9. PalindromeNumber</title>
      <link>https://dinwy.github.io/algorithm/2020/ReverseIntegerAndPalindromeNumber/</link>
      <pubDate>Wed, 11 Mar 2020 19:24:54 +0900</pubDate>
      
      <guid>https://dinwy.github.io/algorithm/2020/ReverseIntegerAndPalindromeNumber/</guid>
      <description>Preface I&amp;rsquo;m trying to take a Easy difficulty ones to warm up my coding practice.
Link https://leetcode.com/problems/reverse-integer/ https://leetcode.com/problems/palindrome-number/
Summary Solving these two problem wasn&amp;rsquo;t hard. Both are asking the same thing. Can you pop number from integer rather than using string  However re-learning that pop = x % 10 &amp;amp; x /= 10
Solution 7.ReverseInteger public class ReverseInteger { public int Solution(int x) { var str = x.ToString(); var leng = x &amp;lt; 0 ?</description>
    </item>
    
    <item>
      <title>LeetCode/3. Add Two Numbers</title>
      <link>https://dinwy.github.io/algorithm/2020/AddTwoNumbers/</link>
      <pubDate>Tue, 10 Mar 2020 21:30:57 +0900</pubDate>
      
      <guid>https://dinwy.github.io/algorithm/2020/AddTwoNumbers/</guid>
      <description>Preface I&amp;rsquo;ve solved this problem a year ago with a weird way. Today I&amp;rsquo;ve reviewed this problem.
Link  https://leetcode.com/problems/add-two-numbers  Summary Reviewing this problem took more than an hour, which made me disappointed and surprise me.  I was very confused assigning outputTail. Same as
{ l1 = l1.next; l2 = l2.next; outputTail = outputTail.next; }  By assigning nextNode to the currentNode which will make loop end at some point.</description>
    </item>
    
    <item>
      <title>Udemy/11Essential: Rotating 2D array 90 degree</title>
      <link>https://dinwy.github.io/algorithm/2020/Rotating2DArray/</link>
      <pubDate>Mon, 17 Feb 2020 22:47:51 +0900</pubDate>
      
      <guid>https://dinwy.github.io/algorithm/2020/Rotating2DArray/</guid>
      <description>Preface It is a interesting question that how to solve this problem. It was really easy to solve this with temp array and copy the value with recursive function. However I was quite confused how to solve in-array When I was solving this problem I was quite confused how to move the element to the array.
My Solution # Recursive solution def rotate(given_array, n): rotated = copy.deepcopy(given_array) for pRow in range(n): for pCol in range(n): rotated[pCol][(n - 1) - pRow] = given_array[pRow][pCol] return given_array  # In-place solution def rotate(given_array, n): for y in range((int)(n / 2)): for x in range(math.</description>
    </item>
    
    <item>
      <title>LeetCode/387. First Unique Character in a String</title>
      <link>https://dinwy.github.io/algorithm/2020/NonRepeatingCharacter/</link>
      <pubDate>Wed, 12 Feb 2020 23:15:22 +0900</pubDate>
      
      <guid>https://dinwy.github.io/algorithm/2020/NonRepeatingCharacter/</guid>
      <description> https://leetcode.com/problems/first-unique-character-in-a-string
Basically this question is asking you about how to you Dictionary. Understanding how to handle key and value and index, can solve this problem easily.
My Solution class Solution(object): def firstUniqChar(self, s): strDict = {} for item in s: if (item in strDict): strDict[item] += 1 else: strDict[item] = 1 for idx, key in enumerate(s): if strDict[key] == 1: return idx return -1  </description>
    </item>
    
  </channel>
</rss>